<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>BRAINROT TYCOON: SPREAD & RARITY</title>
    <style>
        body { margin: 0; overflow: hidden; background: #87CEEB; font-family: 'Arial Black', sans-serif; }
        #stats { position: absolute; top: 10px; left: 10px; color: yellow; font-size: 24px; background: rgba(0,0,0,0.8); padding: 15px; border-radius: 10px; z-index: 10; border: 2px solid #fff; }
        #upgrade-btn { position: absolute; top: 10px; right: 10px; padding: 15px 25px; background: #ff00ff; color: white; border: 4px solid #fff; cursor: pointer; font-size: 20px; z-index: 11; border-radius: 10px; }
        #slow-mode-btn { margin-top: 10px; padding: 5px 10px; background: #555; color: white; border: 2px solid #fff; cursor: pointer; font-size: 14px; border-radius: 5px; width: 100%; }
        #slow-mode-btn.active { background: #00ffff; color: #000; }
        #interact-ui { position: absolute; bottom: 20%; left: 50%; transform: translateX(-50%); color: white; font-size: 24px; text-align: center; display: none; background: rgba(0,0,0,0.8); padding: 15px 30px; border-radius: 15px; border: 2px solid #fff; }
        #progress-bar { width: 200px; height: 10px; background: #555; margin-top: 10px; border: 1px solid #fff; }
        #progress-fill { width: 0%; height: 100%; background: #00ff00; }
    </style>
</head>
<body>
    <div id="stats">
        ðŸ’° Wallet: $<span id="m">0</span><br>
        âš¡ Speed: <span id="speed-val">18</span><br>
        <button id="slow-mode-btn">SLOW MODE: OFF</button>
    </div>
    <button id="upgrade-btn">ðŸ‘¤ +10 SPEED ($50)</button>

    <div id="interact-ui">
        <span id="int-text">HOLD E</span>
        <div id="progress-bar"><div id="progress-fill"></div></div>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const ambient = new THREE.AmbientLight(0xffffff, 1.5);
        scene.add(ambient);
        const sun = new THREE.DirectionalLight(0xffffff, 1.0);
        sun.position.set(50, 100, 50);
        scene.add(sun);

        // --- STATE ---
        window.upgradedSpeed = 18; window.isSlowMode = false; window.wallet = 0; window.speedCost = 50;

        // --- MAP ---
        const mapWidth = 160, mapLength = 1600, safeLineZ = 400, baseZ = 600, spawnZ = -800;
        const ground = new THREE.Mesh(new THREE.PlaneGeometry(mapWidth, mapLength), new THREE.MeshStandardMaterial({ color: 0x22ff22 }));
        ground.rotation.x = -Math.PI / 2; scene.add(ground);

        const wallMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
        const walls = [{s:[10,60,mapLength],p:[-85,30,0]}, {s:[10,60,mapLength],p:[85,30,0]}, {s:[170,60,10],p:[0,30,spawnZ]}, {s:[170,60,10],p:[0,30,baseZ+200]}];
        walls.forEach(w => { const m=new THREE.Mesh(new THREE.BoxGeometry(...w.s), wallMat); m.position.set(...w.p); scene.add(m); });

        const safetyLine = new THREE.Mesh(new THREE.BoxGeometry(160, 2, 10), new THREE.MeshStandardMaterial({color: 0xffff00}));
        safetyLine.position.set(0, 1, safeLineZ); scene.add(safetyLine);

        // --- TRENCHES (DIRT GEOMETRY PRESERVED) ---
        const trenches = [];
        const dirtMat = new THREE.MeshStandardMaterial({ color: 0x5C4033 }); 
        for(let i=0; i<8; i++) {
            const zPos = safeLineZ - 100 - (i * 140);
            const tFloor = new THREE.Mesh(new THREE.BoxGeometry(160, 1, 30), dirtMat); tFloor.position.set(0, -4.5, zPos); scene.add(tFloor);
            const wallF = new THREE.Mesh(new THREE.BoxGeometry(160, 6, 4), dirtMat); wallF.position.set(0, -2, zPos + 15); scene.add(wallF);
            const wallB = new THREE.Mesh(new THREE.BoxGeometry(160, 6, 4), dirtMat); wallB.position.set(0, -2, zPos - 15); scene.add(wallB);
            trenches.push({ z: zPos });
        }

        // --- PLAYER ---
        const player = new THREE.Group();
        const pBody = new THREE.Mesh(new THREE.BoxGeometry(1.5, 2, 0.8), new THREE.MeshStandardMaterial({color: 0xffffff}));
        const pHead = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.2, 1.2), new THREE.MeshStandardMaterial({color: 0x000000}));
        pHead.position.y = 1.6; player.add(pBody, pHead);
        const carryContainer = new THREE.Group(); carryContainer.position.y = 4.5; player.add(carryContainer);
        const arrow = new THREE.Mesh(new THREE.ConeGeometry(1, 2, 8), new THREE.MeshBasicMaterial({color: 0xffff00, depthTest: false}));
        arrow.rotation.x = Math.PI; arrow.position.y = 7.5; arrow.visible = false; arrow.renderOrder = 10000;
        player.add(arrow); player.position.set(0, 1.5, baseZ + 50); scene.add(player);

        // --- UPDATED WEIGHTED SPREAD SPAWNING ---
        const brainrots = [];
        const geometries = [new THREE.BoxGeometry(2,2,2), new THREE.SphereGeometry(1.2,16,16), new THREE.ConeGeometry(1.5,2.5,8), new THREE.TorusGeometry(1,0.4,8,16)];
        function spawnB() {
            // Pick a Z coordinate: biased towards the base (safeLineZ)
            // Using a square to make the back extremely sparse
            const rand = Math.random();
            const z = safeLineZ - (Math.pow(rand, 1.5) * (safeLineZ - spawnZ - 50));
            
            // Determine rarity based on distance from base
            const distanceFactor = (safeLineZ - z) / (safeLineZ - spawnZ); // 0 at base, 1 at back wall
            const roll = Math.random();
            
            let mut="NORMAL", color=new THREE.Color(Math.random()*0xffffff), val=10;
            
            // Diamond only spawns far back (factor > 0.7)
            if(distanceFactor > 0.7 && roll < 0.15) { mut="DIAMOND"; color.set(0x00ffff); val=200; }
            // Gold spawns in middle-back (factor > 0.4)
            else if(distanceFactor > 0.4 && roll < 0.25) { mut="GOLD"; color.set(0xffd700); val=50; }
            
            const b = new THREE.Mesh(geometries[Math.floor(Math.random()*geometries.length)], new THREE.MeshStandardMaterial({ color, emissive: color, emissiveIntensity: 0.2 }));
            b.position.set(Math.random()*140-70, 1.5, z);
            b.userData = { income: val, color, mut, geo: b.geometry };
            scene.add(b); brainrots.push(b);
        }
        for(let i=0; i<35; i++) spawnB();

        // --- UI & TYCOON ---
        function createBtnTex(text, color) {
            const canvas = document.createElement('canvas'); canvas.width = 256; canvas.height = 256;
            const ctx = canvas.getContext('2d'); ctx.fillStyle = color; ctx.fillRect(0,0,256,256);
            ctx.fillStyle = 'white'; ctx.font = 'Bold 35px Arial'; ctx.textAlign = 'center';
            text.split('\n').forEach((t, i) => ctx.fillText(t, 128, 110 + i*50));
            return new THREE.CanvasTexture(canvas);
        }
        function createLabelMat(text1, text2, color) {
            const canvas = document.createElement('canvas'); canvas.width = 512; canvas.height = 200;
            const ctx = canvas.getContext('2d'); ctx.clearRect(0,0,512,200);
            ctx.fillStyle = color; ctx.font = 'Bold 55px Arial'; ctx.textAlign = 'center';
            ctx.fillText(text1, 256, 80); ctx.font = 'Bold 40px Arial'; ctx.fillText(text2, 256, 150);
            return new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas) });
        }
        function updateUI() { 
            document.getElementById('m').innerText = Math.floor(window.wallet); 
            document.getElementById('speed-val').innerText = Math.floor(window.isSlowMode ? 18 : window.upgradedSpeed); 
            document.getElementById('upgrade-btn').innerText = `ðŸ‘¤ +10 SPEED ($${Math.floor(window.speedCost)})`;
        }

        document.getElementById('upgrade-btn').onclick = () => { if(window.wallet >= window.speedCost) { window.wallet -= window.speedCost; window.upgradedSpeed += 10; window.speedCost *= 3; updateUI(); } };
        const slowBtn = document.getElementById('slow-mode-btn');
        slowBtn.onclick = () => { window.isSlowMode = !window.isSlowMode; slowBtn.innerText = window.isSlowMode ? "SLOW MODE: ON" : "SLOW MODE: OFF"; slowBtn.classList.toggle('active'); updateUI(); };

        const slots = [];
        for(let i=0; i<10; i++) {
            const g = new THREE.Group();
            const colBtn = new THREE.Mesh(new THREE.BoxGeometry(5, 0.6, 5), new THREE.MeshStandardMaterial({ map: createBtnTex("$0\nCOLLECT", "#00aa00") }));
            colBtn.position.set(-3, 1, 3);
            const upBtn = new THREE.Mesh(new THREE.BoxGeometry(5, 0.6, 5), new THREE.MeshStandardMaterial({ map: createBtnTex("LVL 1\n$100", "#0000aa") }));
            upBtn.position.set(3, 1, 3);
            const label = new THREE.Sprite(createLabelMat("EMPTY", "WALK HERE", "#555555"));
            label.position.y = 7; label.scale.set(12, 5, 1);
            g.add(new THREE.Mesh(new THREE.BoxGeometry(12,2,12), new THREE.MeshStandardMaterial({color: 0x444444})), colBtn, upBtn, label);
            g.position.set(-45 + (i%5 * 22), 0.5, baseZ + 60 + (Math.floor(i/5) * 30)); scene.add(g);
            slots.push({ g, colBtn, upBtn, label, isActive: false, income: 0, storedCash: 0, lvl: 1, upCost: 100, data: null });
        }

        const keys = {}; const waves = []; let lastWave = 0, holdTime = 0, heldItem = null;
        window.onkeydown=(e)=>keys[e.code]=true; window.onkeyup=(e)=>{keys[e.code]=false; if(e.code==='KeyE')holdTime=0;};
        setInterval(() => { slots.forEach(s => { if(s.isActive) { s.storedCash += s.income; s.colBtn.material.map = createBtnTex(`$${Math.floor(s.storedCash)}\nCOLLECT`, "#00aa00"); } }); }, 1000);

        function animate(time) {
            requestAnimationFrame(animate);
            if(time - lastWave > 4000) {
                const roll = Math.random(); let color, speed;
                if(roll < 0.2) { color = 0xff0000; speed = 7.5; } else if(roll < 0.5) { color = 0x00ff00; speed = 4.5; } else { color = 0x0066ff; speed = 2.5; }
                const w = new THREE.Mesh(new THREE.PlaneGeometry(170, 80), new THREE.MeshStandardMaterial({ color, transparent: true, opacity: 0.7, side: THREE.DoubleSide }));
                w.position.set(0, 40, spawnZ + 20); w.userData = { speed }; scene.add(w); waves.push(w); lastWave = time;
            }

            const sDown = keys['KeyS'];
            let currentMoveSpeed = window.isSlowMode ? 18 : window.upgradedSpeed;
            const moveAmt = currentMoveSpeed * 0.05;
            let nX = player.position.x, nZ = player.position.z;

            if(keys['KeyW']) nZ -= moveAmt; if(sDown) nZ += moveAmt;
            if(keys['KeyA']) nX += sDown ? moveAmt : -moveAmt; if(keys['KeyD']) nX += sDown ? -moveAmt : moveAmt;

            if(nX > -75 && nX < 75) player.position.x = nX;
            if(nZ > spawnZ + 10 && nZ < baseZ + 180) player.position.z = nZ;
            player.rotation.y = sDown ? Math.PI : 0;

            let inT = false;
            trenches.forEach(t => { if(Math.abs(player.position.z - t.z) < 15 && player.position.z < safeLineZ) inT = true; });
            player.position.y = THREE.MathUtils.lerp(player.position.y, inT ? -3.5 : 1.5, 0.1);

            waves.forEach((w, i) => {
                w.position.z += w.userData.speed;
                if(w.position.z >= safeLineZ) { scene.remove(w); waves.splice(i,1); return; }
                if(!inT && Math.abs(w.position.z - player.position.z) < 8) { player.position.set(0, 1.5, baseZ + 50); heldItem = null; arrow.visible = false; carryContainer.clear(); }
            });

            const nearB = brainrots.find(b => player.position.distanceTo(b.position) < 8);
            const nearS = slots.find(sl => player.position.distanceTo(sl.g.position) < 12);
            const ui = document.getElementById('interact-ui');

            if(nearB && !heldItem) {
                ui.style.display = 'block'; document.getElementById('int-text').innerHTML = `<span style="color:${nearB.userData.color.getStyle()}">${nearB.userData.mut}</span><br>HOLD E`;
                if(keys['KeyE']) {
                    holdTime += 16; document.getElementById('progress-fill').style.width = (holdTime/1000*100)+'%';
                    if(holdTime > 1000) { heldItem = nearB.userData; scene.remove(nearB); brainrots.splice(brainrots.indexOf(nearB),1); spawnB(); holdTime = 0; arrow.visible = true; carryContainer.add(new THREE.Mesh(heldItem.geo, new THREE.MeshStandardMaterial({ color: heldItem.color, emissive: heldItem.color, emissiveIntensity: 0.5 }))); }
                }
            } else if(nearS && heldItem) {
                ui.style.display = 'block'; document.getElementById('int-text').innerText = "TAP E TO SWAP/PLACE";
                if(keys['KeyE']) { 
                    if(nearS.isActive) window.wallet += (nearS.income * 10);
                    nearS.isActive = true; nearS.income = heldItem.income; nearS.data = { mut: heldItem.mut, color: heldItem.color.getStyle() };
                    nearS.label.material = createLabelMat(nearS.data.mut, `$${nearS.income.toFixed(1)}/s`, nearS.data.color);
                    heldItem = null; arrow.visible = false; carryContainer.clear(); updateUI();
                }
            } else { ui.style.display = 'none'; document.getElementById('progress-fill').style.width = '0%'; }

            slots.forEach(sl => {
                if(!sl.isActive) return;
                if(player.position.distanceTo(sl.g.position.clone().add(new THREE.Vector3(-3,1,3))) < 5 && sl.storedCash > 0) { window.wallet += sl.storedCash; sl.storedCash = 0; sl.colBtn.material.map = createBtnTex(`$0\nCOLLECT`, "#00aa00"); updateUI(); }
                if(player.position.distanceTo(sl.g.position.clone().add(new THREE.Vector3(3,1,3))) < 5 && window.wallet >= sl.upCost) { window.wallet -= sl.upCost; sl.lvl++; sl.income += (sl.income * 0.1); sl.upCost *= 3; sl.upBtn.material.map = createBtnTex(`LVL ${sl.lvl}\n$${sl.upCost}`, "#0000aa"); sl.label.material = createLabelMat(sl.data.mut, `$${sl.income.toFixed(1)}/s`, sl.data.color); updateUI(); }
            });

            // CAMERA REVERSE LOGIC
            arrow.rotation.y += 0.05;
            let camOffset = sDown ? new THREE.Vector3(0, 30, -50) : new THREE.Vector3(0, 30, 50);
            let lookAtPos = sDown ? player.position.clone().add(new THREE.Vector3(0, 0, 60)) : player.position.clone().add(new THREE.Vector3(0, 0, -60));
            camera.position.lerp(player.position.clone().add(camOffset), 0.1);
            camera.lookAt(lookAtPos);
            renderer.render(scene, camera);
        }
        animate(0);
    </script>
</body>
</html>
